<!doctype html><html><head><meta charset=utf-8><style type='text/css'>ul.block{background-color: #f6f8fb; margin-top: 1rem}body{background-color: #b0c4de}li{list-style-type: none;}</style></head><body><div style='margin-bottom: 1.5rem; background-color: #FFDDAA'><h1> Comment Coverage </h1><h2> LOC: 756</h2><h2> Commented Blocks: 69</h2><h2> CB per line: 0.09126984126984126 (max: 0.5) </h2><h2> CB per line: 18.253968253968253 % </h2><h2> lines per CB: 10.956521739130435</h2></div><ul class='block'><li class='comments'><code>/* -*- Mode: Java; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /</code></li><li class='comments'><code>/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */</code></li><li class='comments'><code></code></li><li class='comments'><code>'use strict';</code></li><li class='comments'><code></code></li><li class='comments'><code>/**</code></li><li class='comments'><code> * This is one of possible LockScreen unlockers, and is the default unlocker</code></li><li class='comments'><code> * would be used in Gaia. It's possible to follow the strategy pattern described</code></li><li class='comments'><code> * in the LockSreen to make more unlockers.</code></li><li class='comments'><code> */</code></li><li class='block'><code></code></li><li class='block'><code>(function(exports) {</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * We should care about the need of testing,</code></li><li class='comments'><code>   * and make all stateful objects become instance-able.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {LockScreen.intentionRouter} |ir|</code></li><li class='comments'><code>   * @constructor</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  var LockScreenSlide = function(ir) {</code></li><li class='block'><code>    this.initialize(ir);</code></li><li class='block'><code>  };</code></li><li class='block'><code></code></li><li class='block'><code>  var LockScreenSlidePrototype = {</code></li><li class='block'><code>    canvas: null,</code></li><li class='block'><code>    arrows: {</code></li><li class='block'><code>      left: null, right: null,</code></li></ul><ul class='block'><li class='comments'><code>      // Left and right drawing origin.</code></li><li class='block'><code>      ldraw: {x: null, y: null},</code></li><li class='block'><code>      rdraw: {x: null, y: null}</code></li><li class='block'><code>    },</code></li><li class='block'><code></code></li><li class='block'><code>    slides: {</code></li><li class='block'><code>      left: null,</code></li><li class='block'><code>      right: null</code></li><li class='block'><code>    },</code></li><li class='block'><code></code></li><li class='block'><code>    areas: {</code></li><li class='block'><code>      camera: null,</code></li><li class='block'><code>      unlock: null</code></li><li class='block'><code>    },</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>    // The handle area can touch by the user.</code></li><li class='block'><code>    area: null,</code></li><li class='block'><code>    overlay: null,</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>    width: 0, // We need dynamic length here.</code></li><li class='block'><code>    height: 80,</code></li><li class='block'><code>    center: {x: null, y: null},</code></li><li class='block'><code></code></li><li class='block'><code>    handle: {</code></li></ul><ul class='block'><li class='comments'><code>      // Whether we need to auto extend the handle.</code></li><li class='block'><code>      autoExpand: {</code></li><li class='block'><code>        accFactorOriginal: 1.0,</code></li></ul><ul class='block'><li class='comments'><code>        accFactor: 1.0,     // Accelerate sliding if user's finger crossed.</code></li><li class='block'><code>        accFactorMax: 1.3,</code></li><li class='block'><code>        accFactorInterval: 0.02,</code></li></ul><ul class='block'><li class='comments'><code>        sentinelOffset: 40,  // How many pixels before reaching end.</code></li><li class='comments'><code>        sentinelWidth: 0   // Max width - offset</code></li><li class='block'><code>      },</code></li></ul><ul class='block'><li class='comments'><code>      bounceBackTime: 200,  // ms</code></li><li class='comments'><code>      radius: 28, // The radius of the handle in pixel.</code></li><li class='block'><code>      lineWidth: 1.6,</code></li></ul><ul class='block'><li class='comments'><code>      maxWidth: 0,  // We need dynamic length here.</code></li><li class='comments'><code>      // If it slide across the boundary to color it.</code></li><li class='comments'><code>      touchedColor: '0, 170, 204', // RGB</code></li><li class='comments'><code>      // The intermediate color of touched color.</code></li><li class='block'><code>      touchedColorStop: '178, 229, 239'</code></li><li class='block'><code>    },</code></li><li class='block'><code></code></li><li class='block'><code>    states: {</code></li></ul><ul class='block'><li class='comments'><code>      // Some elements can only be initialized after initialization...</code></li><li class='block'><code>      delayInitialized: false,</code></li><li class='block'><code>      initialized: false,</code></li><li class='block'><code>      sliding: false,</code></li><li class='block'><code>      slideReachEnd: false,</code></li></ul><ul class='block'><li class='comments'><code>      slidingColorful: false,   // Start to color the handle.</code></li><li class='comments'><code>      slidingColorGradientEnd: false, // Full color the handle.</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Most of them need to be initialized later.</code></li><li class='block'><code>      touch: {</code></li><li class='block'><code>        direction: '',</code></li><li class='block'><code>        touched: false,</code></li><li class='block'><code>        initX: -1,</code></li><li class='block'><code>        pageX: -1,</code></li><li class='block'><code>        pageY: -1,</code></li><li class='block'><code>        tx: -1,</code></li><li class='block'><code>        prevX: -1,</code></li></ul><ul class='block'><li class='comments'><code>        deltaX: 0  // Diff from prevX and current X</code></li><li class='block'><code>      }</code></li><li class='block'><code>    },</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>    // How we communicate with the LockScreen.</code></li><li class='block'><code>    intentionRouter: null</code></li><li class='block'><code>  };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Initialize this unlocker strategy.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {IntentionRouter} |ir| see LockScreen's intentionRouter.</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype.initialize =</code></li><li class='block'><code>    function(ir) {</code></li><li class='block'><code>      this.intentionRouter = ir;</code></li><li class='block'><code>      this._initializeCanvas();</code></li><li class='block'><code>      ir.unlockerInitialize();</code></li><li class='block'><code>      this.states.initialized = true;</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * The dispatcher. Unlocker would manager all its DOMs individually.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {event} |evt|</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype.handleEvent =</code></li><li class='block'><code>    function(evt) {</code></li><li class='block'><code>      switch (evt.type) {</code></li><li class='block'><code>        case 'screenchange':</code></li></ul><ul class='block'><li class='comments'><code>          // Don't lock if screen is turned off by promixity sensor.</code></li><li class='block'><code>          if (evt.detail.screenOffBy == 'proximity') {</code></li><li class='block'><code>            break;</code></li><li class='block'><code>          }</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>          // If the screen got blackout, we should restore the slide.</code></li><li class='block'><code>          this._clearCanvas();</code></li><li class='block'><code>          this._resetArrows();</code></li><li class='block'><code>          this._resetHandle();</code></li><li class='block'><code>          break;</code></li><li class='block'><code>        case 'click':</code></li><li class='block'><code>            if (evt.target === this.areas.unlock) {</code></li><li class='block'><code>              this.intentionRouter.activateUnlock();</code></li><li class='block'><code>            } else if (evt.target === this.areas.camera) {</code></li><li class='block'><code>              this.intentionRouter.activateCamera();</code></li><li class='block'><code>            }</code></li><li class='block'><code>            evt.preventDefault();</code></li><li class='block'><code>          break;</code></li><li class='block'><code></code></li><li class='block'><code>        case 'touchstart':</code></li><li class='block'><code>            if (evt.target === this.areas.unlock) {</code></li><li class='block'><code>              this.intentionRouter.activateUnlock();</code></li><li class='block'><code>            } else if (evt.target === this.areas.camera) {</code></li><li class='block'><code>              this.intentionRouter.activateCamera();</code></li><li class='block'><code>            } else if (evt.target === this.area) {</code></li><li class='block'><code>              this._onSlideBegin(this._dpx(evt.touches[0].pageX));</code></li><li class='block'><code>            }</code></li><li class='block'><code>            evt.preventDefault();</code></li><li class='block'><code>            window.addEventListener('touchend', this);</code></li><li class='block'><code>            window.addEventListener('touchmove', this);</code></li><li class='block'><code>          break;</code></li><li class='block'><code></code></li><li class='block'><code>        case 'touchmove':</code></li></ul><ul class='block'><li class='comments'><code>          // Records touch states.</code></li><li class='block'><code>          this._onTouchMove(</code></li><li class='block'><code>            this._dpx(evt.touches[0].pageX),</code></li><li class='block'><code>            this._dpx(evt.touches[0].pageY)</code></li><li class='block'><code>          );</code></li><li class='block'><code>          if (this.states.sliding) {</code></li><li class='block'><code>            this._onSliding(this._dpx(evt.touches[0].pageX));</code></li><li class='block'><code>          }</code></li><li class='block'><code>          break;</code></li><li class='block'><code></code></li><li class='block'><code>        case 'touchend':</code></li><li class='block'><code>          window.removeEventListener('touchmove', this);</code></li><li class='block'><code>          window.removeEventListener('touchend', this);</code></li><li class='block'><code></code></li><li class='block'><code>          if (this.states.sliding) {</code></li><li class='block'><code>            this._onSlideEnd();</code></li><li class='block'><code>          }</code></li><li class='block'><code></code></li><li class='block'><code>          this.overlay.classList.remove('touched');</code></li><li class='block'><code>          break;</code></li><li class='block'><code>      }</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Initialize the canvas.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._initializeCanvas =</code></li><li class='block'><code>    function lss_initializeCanvas() {</code></li><li class='block'><code></code></li><li class='block'><code>      this.overlay = document.getElementById('lockscreen');</code></li><li class='block'><code>      this.area = document.getElementById('lockscreen-area');</code></li><li class='block'><code>      this.canvas = document.getElementById('lockscreen-canvas');</code></li><li class='block'><code>      this.areas.camera = document.getElementById('lockscreen-area-camera');</code></li><li class='block'><code>      this.areas.unlock = document.getElementById('lockscreen-area-unlock');</code></li><li class='block'><code></code></li><li class='block'><code>      this.area.addEventListener('touchstart', this);</code></li><li class='block'><code>      this.areas.camera.addEventListener('click', this);</code></li><li class='block'><code>      this.areas.unlock.addEventListener('click', this);</code></li><li class='block'><code></code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code>      this.arrows.left = new Image();</code></li><li class='block'><code>      this.arrows.right = new Image();</code></li><li class='block'><code>      var larrow = this.arrows.left;</code></li><li class='block'><code>      var rarrow = this.arrows.right;</code></li><li class='block'><code>      larrow.src = '/style/lockscreen/images/larrow.png';</code></li><li class='block'><code>      rarrow.src = '/style/lockscreen/images/rarrow.png';</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // XXX: Bet it would be OK while user start to drag the slide.</code></li><li class='block'><code>      larrow.onload = (function() {</code></li><li class='block'><code>        this.arrows.ldraw.x =</code></li><li class='block'><code>              center.x - (this.arrows.left.width << 1);</code></li><li class='block'><code>        this.arrows.ldraw.y =</code></li><li class='block'><code>              center.y - (this.arrows.left.height >> 1);</code></li><li class='block'><code>        var ctx = this.canvas.getContext('2d');</code></li><li class='block'><code>        ctx.drawImage(this.arrows.left,</code></li><li class='block'><code>            this.arrows.ldraw.x,</code></li><li class='block'><code>            this.arrows.ldraw.y);</code></li><li class='block'><code>      }).bind(this);</code></li><li class='block'><code>      rarrow.onload = (function() {</code></li><li class='block'><code>        this.arrows.rdraw.x =</code></li><li class='block'><code>              center.x + (this.arrows.right.width);</code></li><li class='block'><code>        this.arrows.rdraw.y =</code></li><li class='block'><code>              center.y - (this.arrows.right.height >> 1);</code></li><li class='block'><code>        var ctx = this.canvas.getContext('2d');</code></li><li class='block'><code>        ctx.drawImage(this.arrows.right,</code></li><li class='block'><code>            this.arrows.rdraw.x,</code></li><li class='block'><code>            this.arrows.rdraw.y);</code></li><li class='block'><code>      }).bind(this);</code></li><li class='block'><code></code></li><li class='block'><code>      this.width = this._dpx(window.innerWidth);</code></li><li class='block'><code>      this.height = this._dpx(80);</code></li><li class='block'><code></code></li><li class='block'><code>      this.canvas.width = this.width;</code></li><li class='block'><code>      this.canvas.height = this.height;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Shrink the canvas back to keep the density.</code></li><li class='block'><code>      this.canvas.style.width = window.innerWidth + 'px';</code></li><li class='block'><code>      this.canvas.style.height = 80 + 'px';</code></li><li class='block'><code></code></li><li class='block'><code>      this.center.x =</code></li><li class='block'><code>        this.canvas.offsetLeft + this.canvas.width >> 1;</code></li><li class='block'><code>      this.center.y =</code></li><li class='block'><code>        this.canvas.offsetHeight + this.canvas.height >> 1;</code></li><li class='block'><code></code></li><li class='block'><code>      this.handle.radius =</code></li><li class='block'><code>        this._dpx(this.handle.radius);</code></li><li class='block'><code></code></li><li class='block'><code>      this.handle.lineWidth =</code></li><li class='block'><code>        this._dpx(this.handle.lineWidth);</code></li><li class='block'><code></code></li><li class='block'><code>      this.handle.autoExpand.sentinelOffset =</code></li><li class='block'><code>        this._dpx(this.handle.autoExpand.sentinelOffset);</code></li><li class='block'><code></code></li><li class='block'><code>      this.canvas.getContext('2d').save();</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Need to move the context toward right, to compensate the circle which</code></li><li class='comments'><code>      // would be draw at the center, and make it align too left.</code></li><li class='block'><code>      this.canvas.getContext('2d', this.handle.radius << 1, 0);</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Draw the handle.</code></li><li class='block'><code>      this._resetHandle();</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // We don't reset the arrows because it need to be draw while image</code></li><li class='comments'><code>      // got loaded, which is a asynchronous process.</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Finalize the canvas: restore its default states.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._finalizeCanvas =</code></li><li class='block'><code>    function lss_finalizeCanvas() {</code></li><li class='block'><code>      this.states.slidingColorful = false;</code></li><li class='block'><code>      this.states.slidingColorGradientEnd = false,</code></li><li class='block'><code>      this._clearCanvas();</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Records how long the user's finger dragged.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |tx| The absolute coordinate of the touching position.</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._onSliding =</code></li><li class='block'><code>    function lss_onSliding(tx) {</code></li><li class='block'><code>      var mtx = this._mapCoord(tx, 0)[0];</code></li><li class='block'><code>      var isLeft = tx - this.center.x < 0;</code></li><li class='block'><code>      this._clearCanvas();</code></li><li class='block'><code></code></li><li class='block'><code>      var expandSentinelR = this.center.x +</code></li><li class='block'><code>        this.handle.autoExpand.sentinelWidth;</code></li><li class='block'><code></code></li><li class='block'><code>      var expandSentinelL = this.center.x -</code></li><li class='block'><code>        this.handle.autoExpand.sentinelWidth;</code></li><li class='block'><code></code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code>      var radius = this.handle.radius;</code></li><li class='block'><code>      var ctx = this.canvas.getContext('2d');</code></li><li class='block'><code></code></li><li class='block'><code>      if (tx > expandSentinelR || tx < expandSentinelL) {</code></li><li class='block'><code>          var slow = false;</code></li><li class='block'><code>          if (isLeft) {</code></li><li class='block'><code>            slow = this.states.touch.deltaX > 0;</code></li><li class='block'><code>          } else {</code></li><li class='block'><code>            slow = this.states.touch.deltaX < 0;</code></li><li class='block'><code>          }</code></li></ul><ul class='block'><li class='comments'><code>          // TODO: XXX: Where we use the previous 'mtx' ?</code></li><li class='block'><code>          mtx = this._accelerateSlide(tx, tx < expandSentinelL, slow);</code></li><li class='block'><code>      } else {</code></li><li class='block'><code>        this.handle.autoExpand.accFactor =</code></li><li class='block'><code>          this.handle.autoExpand.accFactorOriginal;</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Slide must overlay on arrows.</code></li><li class='block'><code>      this._drawArrowsTo(mtx);</code></li><li class='block'><code>      this._drawSlideTo(mtx);</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>/**</code></li><li class='comments'><code>   * Start slide the handle of the lockscreen.</code></li><li class='comments'><code>   * Effect: Will set touch and sliding flag in this.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {tx} The absolute coordinate X of the touch position.</code></li><li class='comments'><code>   * @this {LockScreen}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._onSlideBegin =</code></li><li class='block'><code>    function lss_onSlideBegin(tx) {</code></li><li class='block'><code>      var trackLength = this.areas.unlock.offsetLeft -</code></li><li class='block'><code>                        this.areas.camera.offsetLeft +</code></li><li class='block'><code>                        this.areas.unlock.clientWidth;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Offset and clientWidth would be window size.</code></li><li class='block'><code>      trackLength = this._dpx(trackLength);</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Because the canvas would draw from the center to one point</code></li><li class='comments'><code>      // on the circle, it would add dimeter long distance for one side.</code></li><li class='block'><code>      var maxWidth = (trackLength -</code></li><li class='block'><code>          (this.handle.radius << 1)) >> 1;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Left 1 pixel each side for the border.</code></li><li class='block'><code>      maxWidth -= 2;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Because if we initialize this value while init the lockscreen,</code></li><li class='comments'><code>      // the offset would be zero.</code></li><li class='block'><code>      if (true !== this.states.delayInitialized) {</code></li><li class='block'><code></code></li><li class='block'><code>        this.handle.maxWidth = maxWidth;</code></li><li class='block'><code></code></li><li class='block'><code>        this.handle.autoExpand.sentinelWidth =</code></li><li class='block'><code>          maxWidth - this.handle.autoExpand.sentinelOffset;</code></li><li class='block'><code></code></li><li class='block'><code>        this.delayInitialized = true;</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li><li class='block'><code>      var canvasCenterX = this.canvas.clientWidth >> 1;</code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // To see if the finger touch on the area of the center circle.</code></li><li class='block'><code>      var boundaryR = center.x + this.handle.radius;</code></li><li class='block'><code>      var boundaryL = center.x - this.handle.radius;</code></li><li class='block'><code></code></li><li class='block'><code>      if (tx > boundaryR || tx < boundaryL) {</code></li></ul><ul class='block'><li class='comments'><code>        return; // Do nothing.</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li><li class='block'><code>      this.states.touch.initX = tx;</code></li><li class='block'><code></code></li><li class='block'><code>      this.states.sliding = true;</code></li><li class='block'><code>      this._lightIcons();</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * When user released the finger, bounce it back.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._onSlideEnd =</code></li><li class='block'><code>    function lss_onSlideEnd() {</code></li><li class='block'><code>      var isLeft = this.states.touch.pageX - this.center.x < 0;</code></li><li class='block'><code>      var bounceEnd = (function _bounceEnd() {</code></li><li class='block'><code>        this._clearCanvas();</code></li><li class='block'><code>        this._resetArrows();</code></li><li class='block'><code>        this._resetHandle();</code></li><li class='block'><code>      }).bind(this);</code></li><li class='block'><code></code></li><li class='block'><code>      if (false === this.states.slideReachEnd) {</code></li><li class='block'><code>        this._bounceBack(this.states.touch.pageX, bounceEnd);</code></li><li class='block'><code>      } else {</code></li><li class='block'><code>        var intention = isLeft ? this.intentionRouter.activateCamera :</code></li><li class='block'><code>          this.intentionRouter.activateUnlock;</code></li><li class='block'><code>        intention();</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // Restore it only after screen changed.</code></li><li class='block'><code>        var appLaunchDelay = 400;</code></li><li class='block'><code>        setTimeout(bounceEnd, appLaunchDelay);</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li><li class='block'><code>      this._darkIcons();</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * When touchmove event on, records the information.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |pageX| The absolute coordinate X of the finger.</code></li><li class='comments'><code>   * @param {number} |pageY| The absolute coordinate Y of the finger.</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._onTouchMove =</code></li><li class='block'><code>    function ls_handleMove(pageX, pageY) {</code></li><li class='block'><code>      var touch = this.states.touch;</code></li><li class='block'><code></code></li><li class='block'><code>      if (!touch.touched) {</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // Do nothing if the user have not move the finger to the slide yet.</code></li><li class='block'><code>        if (!this.states.sliding)</code></li><li class='block'><code>          return;</code></li><li class='block'><code></code></li><li class='block'><code>        touch.touched = true;</code></li><li class='block'><code>        touch.initX = pageX;</code></li><li class='block'><code></code></li><li class='block'><code>        var overlay = this.overlay;</code></li><li class='block'><code>        overlay.classList.add('touched');</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li><li class='block'><code>      touch.tx = pageX - touch.initX;</code></li><li class='block'><code>      touch.pageX = pageX;</code></li><li class='block'><code></code></li><li class='block'><code>      if (-1 !== touch.pageX) {</code></li><li class='block'><code>        touch.deltaX = pageX - touch.prevX;</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li><li class='block'><code>      touch.prevX = pageX;</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Accelerate the slide when the finger is near the end.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |tx|</code></li><li class='comments'><code>   * @param {boolean} |isLeft|</code></li><li class='comments'><code>   * @param {boolean} |inverse| (Optional) true if you want to slow rather</code></li><li class='comments'><code>   *                            than accelerate it.</code></li><li class='comments'><code>   * @return {number}</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._accelerateSlide =</code></li><li class='block'><code>    function lss_accelerateSlide(tx, isLeft, inverse) {</code></li><li class='block'><code>      var accFactor = this.handle.autoExpand.accFactor;</code></li><li class='block'><code>      var accFactorMax = this.handle.autoExpand.accFactorMax;</code></li><li class='block'><code>      var accFactorOriginal =</code></li><li class='block'><code>        this.handle.autoExpand.accFactorOriginal;</code></li><li class='block'><code>      var interval = this.handle.autoExpand.accFactorInterval;</code></li><li class='block'><code>      var adjustedAccFactor = isLeft ? 1 / accFactor : accFactor;</code></li><li class='block'><code>      if (!inverse && accFactor + interval < accFactorMax)</code></li><li class='block'><code>        accFactor += interval;</code></li><li class='block'><code>      if (inverse && accFactor - interval > accFactorOriginal)</code></li><li class='block'><code>        accFactor -= interval;</code></li><li class='block'><code>      this.handle.autoExpand.accFactor = accFactor;</code></li><li class='block'><code>      return tx * adjustedAccFactor;</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Clear the canvas.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._clearCanvas =</code></li><li class='block'><code>    function lss_clearCanvas() {</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var ctx = canvas.getContext('2d');</code></li><li class='block'><code>      ctx.clearRect(0, 0, canvas.width, canvas.height);</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Bounce the handle back from the |tx|.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |tx| The absolute horizontal position of the finger.</code></li><li class='comments'><code>   * @param {Function()} |cb| (Optional) Callback. Will be executed after</code></li><li class='comments'><code>   * the animation ended.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._bounceBack =</code></li><li class='block'><code>    function lss_bounceBack(tx, cb) {</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var ctx = canvas.getContext('2d');</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Absolute coordinate of the canvas center.</code></li><li class='block'><code>      var duration = this.handle.bounceBackTime;</code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code>      var nextTx = tx;</code></li><li class='block'><code>      var tsBegin = null;</code></li></ul><ul class='block'><li class='comments'><code>      var mspf = 0; // ms per frame.</code></li><li class='comments'><code>      var interval = 1; // How many pixels per frame should draw.</code></li><li class='comments'><code>      // Draw from the circle center to one end on the circle itself.</code></li><li class='block'><code>      var isLeft = tx - center.x < 0;</code></li><li class='block'><code></code></li><li class='block'><code>      var drawIt = (function _drawIt(ts) {</code></li><li class='block'><code>        if (null === tsBegin)</code></li><li class='block'><code>          tsBegin = ts;</code></li><li class='block'><code></code></li><li class='block'><code>        if (ts - tsBegin < duration) {</code></li><li class='block'><code>          if (0 === mspf)</code></li></ul><ul class='block'><li class='comments'><code>            mspf = ts - tsBegin;  // Not an accurate way to determine mspf.</code></li><li class='block'><code>          interval = Math.abs(center.x - tx) / (duration / mspf);</code></li><li class='block'><code>          nextTx = isLeft ? nextTx + interval : nextTx - interval;</code></li><li class='block'><code>          if ((isLeft && nextTx < center.x) ||</code></li><li class='block'><code>              (!isLeft && nextTx >= center.x)) {</code></li><li class='block'><code>            this._clearCanvas();</code></li><li class='block'><code>            this._drawArrowsTo(nextTx);</code></li><li class='block'><code>            this._drawSlideTo(nextTx);</code></li><li class='block'><code>          }</code></li><li class='block'><code>          requestAnimationFrame(drawIt);</code></li><li class='block'><code>        } else {</code></li></ul><ul class='block'><li class='comments'><code>          // Compensation from the current position to the center of the slide.</code></li><li class='block'><code>          this._clearCanvas();</code></li><li class='block'><code>          this._drawArrowsTo(center.x);</code></li><li class='block'><code>          this._drawSlideTo(center.x);</code></li><li class='block'><code>          if (cb)</code></li><li class='block'><code>            cb();</code></li><li class='block'><code>        }</code></li><li class='block'><code>      }).bind(this);</code></li><li class='block'><code>      requestAnimationFrame(drawIt);</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Dark the camera and unlocking icons when user leave our LockScreen.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._darkIcons =</code></li><li class='block'><code>    function lss_darkIcons() {</code></li><li class='block'><code>      this.areas.camera.classList.add('dark');</code></li><li class='block'><code>      this.areas.unlock.classList.add('dark');</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Draw the two arrows on the slide.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |tx| The absolute horizontal position of the target.</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._drawArrowsTo =</code></li><li class='block'><code>    function lss_drawArrows(tx) {</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var ctx = canvas.getContext('2d');</code></li><li class='block'><code>      var radius = this.handle.radius;</code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code>      var offset = tx - center.x;</code></li><li class='block'><code>      var isLeft = offset < 0;</code></li><li class='block'><code></code></li><li class='block'><code>      if (this.handle.maxWidth < Math.abs(offset)) {</code></li><li class='block'><code>        this.states.slideReachEnd = true;</code></li><li class='block'><code>        return;</code></li><li class='block'><code>      }</code></li><li class='block'><code>      this.states.slideReachEnd = false;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // The Y of arrows: need to put it from center to sink half of the arrow.</code></li><li class='block'><code>      if (isLeft) {</code></li></ul><ul class='block'><li class='comments'><code>        // XXX:<<1: OK but don't know why!</code></li><li class='block'><code>        ctx.drawImage(this.arrows.left,</code></li><li class='block'><code>          tx - (this.arrows.left.width << 1),</code></li><li class='block'><code>          this.arrows.ldraw.y);</code></li><li class='block'><code>        ctx.drawImage(this.arrows.right,</code></li><li class='block'><code>          this.arrows.rdraw.x,</code></li><li class='block'><code>          this.arrows.ldraw.y);</code></li><li class='block'><code></code></li><li class='block'><code>      } else {</code></li><li class='block'><code>        ctx.drawImage(this.arrows.right,</code></li><li class='block'><code>          tx + this.arrows.right.width,</code></li><li class='block'><code>          this.arrows.rdraw.y);</code></li><li class='block'><code>        ctx.drawImage(this.arrows.left,</code></li><li class='block'><code>          this.arrows.ldraw.x,</code></li><li class='block'><code>          this.arrows.ldraw.y);</code></li><li class='block'><code>      }</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Extend the slide from its center to the specific position.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |tx| The absolute horizontal position of the target.</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._drawSlideTo =</code></li><li class='block'><code>    function lss_drawSlideTo(tx) {</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var ctx = canvas.getContext('2d');</code></li><li class='block'><code>      var maxWidth = this.handle.maxWidth;</code></li><li class='block'><code></code></li><li class='block'><code>      var offset = tx;</code></li><li class='block'><code>      var radius = this.handle.radius;</code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // The width and height of the rectangle.</code></li><li class='block'><code>      var rw = offset - center.x;</code></li><li class='block'><code>      var urw = Math.abs(rw);</code></li><li class='block'><code></code></li><li class='block'><code>      if (this.handle.maxWidth < urw) {</code></li><li class='block'><code>        offset = rw > 0 ? center.x + maxWidth : center.x - maxWidth;</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // 1.5 ~ 0.5 is the right part of a circle.</code></li><li class='block'><code>      var startAngle = 1.5 * Math.PI;</code></li><li class='block'><code>      var endAngle = 0.5 * Math.PI;</code></li><li class='block'><code>      var fillAlpha = 0.0;</code></li><li class='block'><code>      var strokeStyle = 'white';</code></li><li class='block'><code>      const GRADIENT_LENGTH = 50;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // If user move over 15px, fill the slide.</code></li><li class='block'><code>      if (urw > 15 && true !== this.states.slidingColorful) {</code></li></ul><ul class='block'><li class='comments'><code>        // The color should be gradient in this length, from the origin.</code></li><li class='comments'><code>        // It would decide how long the color turning to the touched color.</code></li><li class='block'><code></code></li><li class='block'><code>        fillAlpha = (urw - 15) / GRADIENT_LENGTH;</code></li><li class='block'><code>        if (fillAlpha > 1.0) {</code></li><li class='block'><code>          fillAlpha = 1.0;</code></li><li class='block'><code>          this.states.slidingColorGradientEnd = true;</code></li><li class='block'><code>        }</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // The border must disappear during the sliding,</code></li><li class='comments'><code>        // so it's alpha would decrease to zero.</code></li><li class='block'><code>        var borderAlpha = 1.0 - fillAlpha;</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // From white to covered blue.</code></li><li class='block'><code>        strokeStyle = 'rgba(' + this.handle.touchedColorStop +</code></li><li class='block'><code>          ',' + borderAlpha + ')';</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // It's colorful now.</code></li><li class='block'><code>        this.states.slidingColorful = true;</code></li><li class='block'><code>      } else {</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>        // Has pass the stage of gradient color.</code></li><li class='block'><code>        if (true === this.states.slidingColorGradientEnd) {</code></li><li class='block'><code>          fillAlpha = 1.0;</code></li><li class='block'><code>          var color = this.handle.touchedColor;</code></li></ul><ul class='block'><li class='comments'><code>        } else if (0 === urw) {  // Draw as the initial circle.</code></li><li class='block'><code>          fillAlpha = 0.0;</code></li><li class='block'><code>          var color = '255,255,255';</code></li><li class='block'><code>        } else {</code></li><li class='block'><code>          fillAlpha = (urw - 15) / GRADIENT_LENGTH;</code></li><li class='block'><code>          if (fillAlpha > 1.0) {</code></li><li class='block'><code>            fillAlpha = 1.0;</code></li><li class='block'><code>            this.states.slidingColorGradientEnd = true;</code></li><li class='block'><code>          }</code></li><li class='block'><code>          var color = this.handle.touchedColorStop;</code></li><li class='block'><code>        }</code></li><li class='block'><code>        var borderAlpha = 1.0 - fillAlpha;</code></li><li class='block'><code>        strokeStyle = 'rgba(' + color + ',' + borderAlpha + ')';</code></li><li class='block'><code>      }</code></li><li class='block'><code>      ctx.fillStyle = 'rgba(' + this.handle.touchedColor +</code></li><li class='block'><code>        ',' + fillAlpha + ')';</code></li><li class='block'><code>      ctx.lineWidth = this.handle.lineWidth;</code></li><li class='block'><code>      ctx.strokeStyle = strokeStyle;</code></li><li class='block'><code></code></li><li class='block'><code>      var counterclock = false;</code></li><li class='block'><code>      if (offset - center.x < 0) {</code></li><li class='block'><code>        counterclock = true;</code></li><li class='block'><code>      }</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Start to draw it.</code></li><li class='comments'><code>      // Can't use functions like rect or these individual parts</code></li><li class='comments'><code>      // would show its borders.</code></li><li class='block'><code>      ctx.beginPath();</code></li><li class='block'><code></code></li><li class='block'><code>      ctx.arc(center.x, center.y,</code></li><li class='block'><code>          radius, endAngle, startAngle, counterclock);</code></li><li class='block'><code>      ctx.lineTo(center.x, center.y - radius);</code></li><li class='block'><code>      ctx.lineTo(center.x + (offset - center.x), center.y - radius);</code></li><li class='block'><code>      ctx.arc(offset, center.y, radius, startAngle, endAngle, counterclock);</code></li><li class='block'><code>      ctx.lineTo(center.x, center.y + radius);</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>      // Note: When setting both the fill and stroke for a shape,</code></li><li class='comments'><code>      // make sure that you use fill() before stroke().</code></li><li class='comments'><code>      // Otherwise, the fill will overlap half of the stroke.</code></li><li class='block'><code>      ctx.fill();</code></li><li class='block'><code>      ctx.stroke();</code></li><li class='block'><code>      ctx.closePath();</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Return the mapping pixels according to the device pixel ratio.</code></li><li class='comments'><code>   * This may need to be put int the shared/js.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |px|</code></li><li class='comments'><code>   * @return {number}</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._dpx =</code></li><li class='block'><code>    function lss_dpx(px) {</code></li><li class='block'><code>      return px * window.devicePixelRatio;</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Light the camera and unlocking icons when user touch on our LockScreen.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._lightIcons =</code></li><li class='block'><code>    function lss_lightIcons() {</code></li><li class='block'><code>      this.areas.camera.classList.remove('dark');</code></li><li class='block'><code>      this.areas.unlock.classList.remove('dark');</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Map absolution X and Y to canvas' X and Y.</code></li><li class='comments'><code>   * Note this should only be used when user want to draw something</code></li><li class='comments'><code>   * follow the user's input. If the canvans need adjust its position,</code></li><li class='comments'><code>   * the absolute coordinates should be used.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @param {number} |x|</code></li><li class='comments'><code>   * @param {number} |y|</code></li><li class='comments'><code>   * @return {[number]} Array of single pair of X and Y</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._mapCoord =</code></li><li class='block'><code>    function lss_mapCoord(x, y) {</code></li><li class='block'><code>      var cw = this.canvas.clientWidth;</code></li><li class='block'><code>      var ch = this.canvas.clientHeight;</code></li><li class='block'><code></code></li><li class='block'><code>      return [cw * x / window.innerWidth,</code></li><li class='block'><code>              ch * y / window.innerHeight];</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Restore the arrow to the original position.</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._resetArrows =</code></li><li class='block'><code>    function lss_restoreArrows() {</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var ctx = canvas.getContext('2d');</code></li><li class='block'><code>      var center = this.center;</code></li><li class='block'><code>      ctx.drawImage(this.arrows.left,</code></li><li class='block'><code>          this.arrows.ldraw.x,</code></li><li class='block'><code>          this.arrows.ldraw.y);</code></li><li class='block'><code>      ctx.drawImage(this.arrows.right,</code></li><li class='block'><code>          this.arrows.rdraw.x,</code></li><li class='block'><code>          this.arrows.rdraw.y);</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li></ul><ul class='block'><li class='comments'><code>  /**</code></li><li class='comments'><code>   * Draw the handle with its initial states (a transparent circle).</code></li><li class='comments'><code>   *</code></li><li class='comments'><code>   * @this {LockScreenSlidePrototype}</code></li><li class='comments'><code>   */</code></li><li class='block'><code>  LockScreenSlidePrototype._resetHandle =</code></li><li class='block'><code>    function lss_resetHandle() {</code></li><li class='block'><code>      this.states.slidingColorful = false;</code></li><li class='block'><code>      this.states.slidingColorGradientEnd = false;</code></li><li class='block'><code>      var canvas = this.canvas;</code></li><li class='block'><code>      var centerx = this.center.x;</code></li><li class='block'><code>      this._drawSlideTo(centerx);</code></li><li class='block'><code>    };</code></li><li class='block'><code></code></li><li class='block'><code>  LockScreenSlide.prototype = LockScreenSlidePrototype;</code></li><li class='block'><code>  exports.LockScreenSlide = LockScreenSlide;</code></li><li class='block'><code>})(window);</code></li><li class='block'><code></code></li></body></html>